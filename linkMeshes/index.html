<!DOCTYPE html>
	<html>
	<head>
		<title>Getting Started with Three.js</title>
		<script src="./three.min.js"></script>
		<script src="./dat.gui.min.js"></script>
		<script src="./STLLoader.js"></script>
		<script>
		window.onload = function() {
      const TrackballControls = require('./TrackballControls.js');
			const geometryUtils_ = require('./geometryUtils_intra');
			const geometryUtils = require('./geometryUtils');
			const _ = require('underscore');

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( 1200, 800 );
			document.body.appendChild( renderer.domElement );

			var scene = new THREE.Scene();

			var axis = new THREE.AxisHelper(30);
			scene.add(axis);

			var camera = new THREE.PerspectiveCamera(
				70,			// Field of view
				800 / 600,		// Aspect ratio
				0.1,			// Near plane
				10000			// Far plane
			);
			// var eye = new THREE.Vector3(300, -300, 0);
			var eye = new THREE.Vector3(70, 20, 20);
			var up  = new THREE.Vector3(0,0,1);
			camera.position.copy( eye );
      camera.up = up;
			camera.rotateZ(-Math.PI/2);
			camera.updateProjectionMatrix();
			console.log(camera)

			var controls = new THREE.TrackballControls(camera);
			controls.rotateSpeed = 2.0;
			controls.update();

			var light1 = new THREE.AmbientLight( 0x666666 );
			var light2 = new THREE.PointLight( 0x666666 );
			light2.position.set( 50, 50, 50 );
			scene.add( light1 );
			scene.add( light2 );

			// ======================================================================================================================================================
			// ======================================================================================================================================================
			// ======================================================================================================================================================
			// performance stats
			// 500 x 5 pts >> 160 ms >> 7'500 pts
			// 5000 x 5 pts >> 13'270 ms >> 75'000 pts
			// 5000 x 20 pts >> 14'000 ms >> 300'000 pts
			// 5000 x 50 pts >> 16'000 ms >> 750'000 pts
			// NOTE !! 85 % CPU time is spent into checkDuplicates // TODO speed up

			// TODO cut points from abt base
			// TODO for first source point, find nearest target point and oder target points in the same order as source points, starting from it

			// two example meshes
			const baseVerticesNumber = 10;
			const N = 50;

			var cyl_g = new THREE.CylinderBufferGeometry(10, 10, 30, baseVerticesNumber, 5, true).applyMatrix(new THREE.Matrix4().makeRotationZ(Math.PI/15));
			// var sq_g  = new THREE.BoxBufferGeometry(10,10,10).applyMatrix(new THREE.Matrix4().makeTranslation(0,30,10));
			var sq_g  = new THREE.CylinderBufferGeometry(10,10,10, baseVerticesNumber, 5, true).applyMatrix(new THREE.Matrix4().makeTranslation(0,35,10));
			var mat   = new THREE.MeshLambertMaterial({color: 'green', wireframe: true});
			var cyl   = new THREE.Mesh(cyl_g, mat);
			var sq    = new THREE.Mesh(sq_g, mat);
			// scene.add(cyl);
			scene.add(sq);

			console.time('select');

			// selecting vertices
			var cylVerts = [];
			var sqVerts  = [];
			var allCylVerts = cyl_g.attributes.position.array;
			var allSqVerts  = sq_g.attributes.position.array;
			for (var i=0; i<allCylVerts.length; i+=3){
				var res = checkDuplicates(cylVerts, [allCylVerts[i], allCylVerts[i+1], allCylVerts[i+2]])
				if (allCylVerts[i+1] > 12 && !res){
					// console.log('point', res, allCylVerts[i], allCylVerts[i+1], allCylVerts[i+2])
					cylVerts.push(cyl_g.attributes.position.array[i]);
					cylVerts.push(cyl_g.attributes.position.array[i+1]);
					cylVerts.push(cyl_g.attributes.position.array[i+2]);
					// var p = new THREE.SphereGeometry(1,32,32);
					// var m = new THREE.MeshBasicMaterial();
					// var point = new THREE.Mesh(p,m);
					// point.position.set(cyl_g.attributes.position.array[i],cyl_g.attributes.position.array[i+1],cyl_g.attributes.position.array[i+2])
					// scene.add(point);
				}
			}
			for (var i=0; i<allSqVerts.length; i+=3){
				var res = checkDuplicates(sqVerts, [allSqVerts[i], allSqVerts[i+1], allSqVerts[i+2]]);
				if (allSqVerts[i+1] < 31 && !res){
					sqVerts.push(sq_g.attributes.position.array[i]);
					sqVerts.push(sq_g.attributes.position.array[i+1]);
					sqVerts.push(sq_g.attributes.position.array[i+2]);
					// var p = new THREE.SphereGeometry(1,32,32);
					// var m = new THREE.MeshBasicMaterial();
					// var point = new THREE.Mesh(p,m);
					// point.position.set(sq_g.attributes.position.array[i],sq_g.attributes.position.array[i+1],sq_g.attributes.position.array[i+2])
					// scene.add(point);
				}
			}

			// load abt
			var loader = new THREE.STLLoader();
			var abtVerts = allAbtVerts = [];

			loader.load('./openAbt.stl', function (geometry) {
				geometry.applyMatrix(new THREE.Matrix4().makeRotationX(Math.PI/2))
				geometry.applyMatrix(new THREE.Matrix4().makeScale(5,5,5))
				allAbtVerts = geometry.attributes.position.array;
				var mesh = new THREE.Mesh(geometry, mat);
				scene.add(mesh);

				for (var i=0; i<allAbtVerts.length; i+=3){
					if (allAbtVerts[i+1] > 1.5){
						// console.log(i, allAbtVerts.length);
						var res = checkDuplicates(abtVerts, [allAbtVerts[i], allAbtVerts[i+1], allAbtVerts[i+2]]);
						if (!res && (i % 10 == 0)){
							abtVerts.push(allAbtVerts[i]);
							abtVerts.push(allAbtVerts[i+1]);
							abtVerts.push(allAbtVerts[i+2]);
							// if (i % 10 == 0){
								console.log(i, allAbtVerts.length);
								var p = new THREE.SphereGeometry(0.05,32,32);
								var m = new THREE.MeshBasicMaterial({color: 'red'});
								var point = new THREE.Mesh(p,m);
								point.position.set(allAbtVerts[i],allAbtVerts[i+1],allAbtVerts[i+2])
								scene.add(point);
							// }
						}
					}
				}
				console.log('abt', abtVerts.length/3);
				console.timeEnd('selecting');

				abtVerts = geometryUtils_.checkProfile(abtVerts);

				generate(abtVerts)
				// generate(cylVerts)
			});

			// console.log('cyl', cylVerts.length);
			// console.log('sq', sqVerts.length);

	function generate(inputVerts){
			console.time('generate')
			// spline & sample sqVerts to have equal number of points
			var sampling = geometryUtils_.plainArrayToThreePointsArray(sqVerts);
			var curve = new THREE.CatmullRomCurve3(sampling, true);
			var sampledPoints = curve.getPoints(inputVerts.length/3);
			sampledPoints.splice(-1); // avoid last-first duplicate
			// console.log('sampledPoints', sampledPoints.length);

			// TODO get nearest point for first point and reorder consequently the target (use 'extrusion direction' !!)
			// compute direction
			var c1 = geometryUtils.getPointsCentroid(geometryUtils_.plainArrayToThreePointsArray(inputVerts));
			var c2 = geometryUtils.getPointsCentroid(sampledPoints);

			var direction = new THREE.Vector3().subVectors(c2,c1).normalize();
			var ah = new THREE.ArrowHelper(direction, c1, 30);
			scene.add(ah);

			var s0 = new THREE.Vector3(inputVerts[0], inputVerts[1], inputVerts[2]);
			// var distances = sampledPoints.map(p => p.distanceTo(s0));
			var distances = sampledPoints.map(p => p.dot(direction));
			var max = Math.max(...distances);
			var nearestId = distances.indexOf(max);
			// var nearestPoint = sampledPoints[nearestId];
			var part1 = sampledPoints.slice(0,nearestId);
			var part2 = sampledPoints.slice(nearestId);
			console.log(part1.length, part2.length, sampledPoints);
			sampledPoints = part2.concat(part1);
			console.log(sampledPoints);

			var s = new THREE.SphereGeometry(0.5, 8,8);
			var srcPoint = new THREE.Mesh(s,m);
			srcPoint.position.copy(s0)
			scene.add(srcPoint);
			var trgPoint = new THREE.Mesh(s,m);
			trgPoint.position.copy(sampledPoints[nearestId]);
			scene.add(trgPoint);

			// end TODO

			// to plain array ...xyzxyz...
			sampledPoints = geometryUtils_.threePointsArrayToPlainArray(sampledPoints);

			// single layer
			// var lg = new THREE.BufferGeometry();
			// var allVerts = sewer(cylVerts, sampledPoints);

			// lg.addAttribute( 'position', new THREE.BufferAttribute( allVerts, 3 ) );
			// var lm = new THREE.MeshBasicMaterial({color: 0x0000ff, side: THREE.DoubleSide, wireframe: true});
			// var link = new THREE.Mesh(lg,lm);
			// scene.add(link);

			// compute N layers
			var cyl_v3_vertices = geometryUtils_.plainArrayToThreePointsArray(inputVerts);
			var sampl_v3_vertices = geometryUtils_.plainArrayToThreePointsArray(sampledPoints);
			var layers = [];

			var raw_layers = cyl_v3_vertices.map(function(v, i){
				var cube_v3 = sampl_v3_vertices[i];
				var line = new THREE.LineCurve3(v, cube_v3);
				var layersPoints = geometryUtils_.threePointsArrayToPlainArray(line.getPoints(N-1));

				return _.chunk(layersPoints, 3);
			});

			// init array of arrays
			var layers = new Array(N).fill(0).map(e => []);

			// fill with layers points
			for (var l=0; l<raw_layers.length; l++){
				for (var m=0; m<raw_layers[l].length; m++){
					layers[m] = layers[m].concat(raw_layers[l][m]);
				}
			}

			// sew each layer with the follower, storing vertices
			var finalVertices = new Float32Array(10000000).fill(99999);

			for (var f=0; f<layers.length-1; f++){
				// console.log(layers[f], layers[f+1]);
				var partialVertices = sewer(layers[f], layers[f+1]);
				// DEV
				// layers[f].forEach(function(p,k,arr){
				// 	if (k%3 === 0){
				// 		var geometry = new THREE.SphereGeometry(0.3,8,8);
				// 		var material = new THREE.MeshBasicMaterial({depthTest:false, color: 'blue'});
				// 		point = new THREE.Mesh(geometry, material);
				// 		point.position.set(arr[k], arr[k+1], arr[k+2]);
				// 		scene.add(point);
				// 	}
				// });
				// if (f === layers.length-2){
				// 	layers[f+1].forEach(function(p,k,arr){
				// 		if (k%3 === 0){
				// 			var geometry = new THREE.SphereGeometry(0.3,8,8);
				// 			var material = new THREE.MeshBasicMaterial({depthTest:false, color: 'blue'});
				// 			point = new THREE.Mesh(geometry, material);
				// 			point.position.set(arr[k], arr[k+1], arr[k+2]);
				// 			scene.add(point);
				// 		}
				// 	});
				// }
				// END DEV
				// console.log(partialVertices.length, '//', finalVertices.length);
				// console.log(layers[f].length*3*f)
				finalVertices.set(partialVertices, layers[f].length*6*f);
			}

			finalVertices = finalVertices.subarray(0, finalVertices.indexOf(99999));
			console.log(finalVertices);

			var lg = new THREE.BufferGeometry();
			lg.addAttribute( 'position', new THREE.BufferAttribute( finalVertices, 3 ) );
			var lm = new THREE.MeshPhongMaterial({flatShading:true, color: 0x0000ff, side: THREE.DoubleSide, wireframe: true});
			var link = new THREE.Mesh(lg,lm);

			console.timeEnd('generate')

			scene.add(link);
			console.log('>>>>>>>>>> final vertices: ', finalVertices.length/3);

		}

		renderer.setClearColor( 0xdddddd, 1);

		function render() {
			requestAnimationFrame( render );
			controls.update(0.5);
			renderer.render( scene, camera );
		}

		render();

			function stretchIt(mesh, point, sf, type, cb){
				var verts = mesh.original.geometry.attributes.position.array.slice();
				mesh.geometry.computeBoundingBox();
				var bb = mesh.geometry.boundingBox;
				var h = bb.max.y - bb.min.y;
				var l = Math.abs(bb.max.y - bb.min.y);

				if(type == 'parabolic') {
					var a1 = (1-sf) / ((l**2)/4 - point.y*l + point.y**2);
					var b1 = -2*a1*point.y;
					var c1 = a1*(point.y**2) + sf;
					var a2 = (1-sf) / ((l**2)/4 + point.y*l + point.y**2);
					var b2 = -2*a2*point.y;
					var c2 = a2*(point.y**2) + sf;
				}
				else if (type == 'linear') {
					var a1 = a2 = 0;

					var b1 = (1-sf) / (l/2 - point.y);
					var c1 = -(point.y - sf*l/2) / (l/2 - point.y);

					var b2 = (1-sf) / -(l/2 + point.y);
					var c2 = -(point.y + sf*l/2) / -(l/2 + point.y);
				}
				else {
					console.warn('no matching type');
					return;
				}

				var strVerts = verts.map(function(v, k, arr){
					var pos = k%3;

					switch(pos){
						case 0:
										y = (arr[k+1]);
										if (y>point.y){
											v *= a1*(y**2) + b1*y + c1;
										}
										else{
											v *= a2*(y**2) + b2*y + c2;
										}
										break;
						case 1:
										v *= 1.0;
										break;
						case 2:
										y = (arr[k-1]);
										if (y>point.y){
											v *= a1*(y**2) + b1*y + c1;
										}
										else{
											v *= a2*(y**2) + b2*y + c2;
										}
										break;
					}
					return v;
				})
				mesh.geometry.attributes.position.array = strVerts.slice();
				mesh.geometry.attributes.position.needsUpdate = true;
				// cb(mesh);
				return mesh;
			}

			function applyStretch(mesh, point, direction, s, sf, type, cb){
				console.time('stretch');
				// move to origin
				var quaternion = new THREE.Quaternion().setFromUnitVectors(direction, new THREE.Vector3(0,1,0));
				var rotMat = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
				var matrix = geometryUtils.translateAxisMatrix(direction, cylHeight/2 + point.length());
				matrix.premultiply(rotMat);
				mesh.geometry.applyMatrix(matrix);
				mesh.original.geometry.applyMatrix(matrix);
				// // stretch
				var bottom = new THREE.Vector3(0, -cylHeight/2, 0);
				var top    = new THREE.Vector3(0, cylHeight/2, 0);
				// correction to avoid mesh distortion on top
				s = s == 1 ? 1.01 : s;
				var center = new THREE.Vector3().lerpVectors(bottom, top, s);
				var stretched = stretchIt(mesh, center, sf, type);
				// // put back in position
				var inverseMatrix = new THREE.Matrix4().getInverse(matrix);
				stretched.geometry.applyMatrix(inverseMatrix);
				stretched.original.geometry.applyMatrix(inverseMatrix);
				// pass to callback
				// cb(stretched);
				console.timeEnd('stretch')
				if (cb){
					cb(mesh);
				}
			}

			function scaleAsymmetric(mesh, point, axis, sf){
				mesh.original.geometry.computeBoundingBox();

				// move to origin
				var quaternion    = new THREE.Quaternion().setFromUnitVectors(axis, new THREE.Vector3(0,1,0));
				var rotMatrix     = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
				var originMatrix  = geometryUtils.translateAxisMatrix(axis, point.length());
				var scalingMatrix = new THREE.Matrix4().makeScale(1,sf,1);
				var backPosMatrix = new THREE.Matrix4().getInverse(originMatrix);
				var quaternion2   = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), axis);
				var backRotMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion2);

				var matrix = new THREE.Matrix4();
				matrix.premultiply(originMatrix);
				matrix.premultiply(rotMatrix);
				matrix.premultiply(scalingMatrix);
				matrix.premultiply(backRotMatrix);
				matrix.premultiply(backPosMatrix);
				mesh.geometry = mesh.original.geometry.clone().applyMatrix(matrix);

			};

			function checkDuplicates(array, [x,y,z]){
				return array.find(function(i,k){
					var dx = Math.abs(array[k]-x);
					var dy = Math.abs(array[k+1]-y);
					var dz = Math.abs(array[k+2]-z);
					return dx<0.001 && dy<0.001 && dz<0.001;
				})
			}

			function sewer(a_verts, b_verts){
				if (a_verts.length !== b_verts.length){
					console.warn('vertices number mismatch');
					return;
				}

				var vertices = new Float32Array(a_verts.length*3*2);
				var vertices1 = new Float32Array(a_verts.length*3);
				var vertices2 = new Float32Array(a_verts.length*3);

				for (var k=0; k<a_verts.length-5; k+=3){
					vertices1[3*k]   = a_verts[k];
					vertices1[3*k+1] = a_verts[k+1];
					vertices1[3*k+2] = a_verts[k+2];
					vertices1[3*k+3] = b_verts[k];
					vertices1[3*k+4] = b_verts[k+1];
					vertices1[3*k+5] = b_verts[k+2];
					vertices1[3*k+6] = a_verts[k+3];
					vertices1[3*k+7] = a_verts[k+4];
					vertices1[3*k+8] = a_verts[k+5];
				}
				vertices1[3*k]   = a_verts[k];
				vertices1[3*k+1] = a_verts[k+1];
				vertices1[3*k+2] = a_verts[k+2];
				vertices1[3*k+3] = b_verts[k];
				vertices1[3*k+4] = b_verts[k+1];
				vertices1[3*k+5] = b_verts[k+2];
				vertices1[3*k+6] = a_verts[0];
				vertices1[3*k+7] = a_verts[1];
				vertices1[3*k+8] = a_verts[2];

				for (n=0; n<b_verts.length-5; n+=3){
					vertices2[3*n]   = b_verts[n];
					vertices2[3*n+1] = b_verts[n+1];
					vertices2[3*n+2] = b_verts[n+2];
					vertices2[3*n+3] = a_verts[n+3];
					vertices2[3*n+4] = a_verts[n+4];
					vertices2[3*n+5] = a_verts[n+5];
					vertices2[3*n+6] = b_verts[n+3];
					vertices2[3*n+7] = b_verts[n+4];
					vertices2[3*n+8] = b_verts[n+5];
				}
				vertices2[3*n]   = b_verts[k];
				vertices2[3*n+1] = b_verts[k+1];
				vertices2[3*n+2] = b_verts[k+2];
				vertices2[3*n+3] = a_verts[0];
				vertices2[3*n+4] = a_verts[1];
				vertices2[3*n+5] = a_verts[2];
				vertices2[3*n+6] = b_verts[0];
				vertices2[3*n+7] = b_verts[1];
				vertices2[3*n+8] = b_verts[2];

				// DEV display w/ different colors
				// console.log(vertices1);
				// console.log(vertices2);
				// var lg1 = new THREE.BufferGeometry();
				// var lg2 = new THREE.BufferGeometry();
				// lg1.addAttribute( 'position', new THREE.BufferAttribute( vertices1, 3 ) );
				// lg2.addAttribute( 'position', new THREE.BufferAttribute( vertices2, 3 ) );
				// var lm1 = new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide});
				// var lm2 = new THREE.MeshBasicMaterial({color: 0x00ff00, side: THREE.DoubleSide});
				// var link1 = new THREE.Mesh(lg1,lm1);
				// var link2 = new THREE.Mesh(lg2,lm2);
				// scene.add(link1);
				// scene.add(link2);

				vertices.set(vertices1, 0);
				vertices.set(vertices2, vertices1.length);

				return vertices;

			}

		};
		</script>
	</head>
	<body></body>
	</html>
